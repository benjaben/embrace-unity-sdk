// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios17.2-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name EmbraceUploadInternal
// swift-module-flags-ignorable: -enable-bare-slash-regex
import EmbraceCommonInternal
import EmbraceOTelInternal
import Foundation
import GRDB
import Network
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct UploadDataRecord : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension EmbraceUploadInternal.UploadDataRecord : GRDB.FetchableRecord, GRDB.PersistableRecord, GRDB.MutablePersistableRecord {
  public static let databaseColumnDecodingStrategy: GRDB.DatabaseColumnDecodingStrategy
  public static let databaseColumnEncodingStrategy: GRDB.DatabaseColumnEncodingStrategy
  public static let persistenceConflictPolicy: GRDB.PersistenceConflictPolicy
}
extension EmbraceUploadInternal.UploadDataRecord : GRDB.TableRecord {
  public static let databaseTableName: Swift.String
}
extension EmbraceUploadInternal.UploadDataRecord : Swift.Equatable {
  public static func == (lhs: EmbraceUploadInternal.UploadDataRecord, rhs: EmbraceUploadInternal.UploadDataRecord) -> Swift.Bool
}
public protocol EmbraceLogUploader : AnyObject {
  func uploadLog(id: Swift.String, data: Foundation.Data, completion: ((Swift.Result<(), any Swift.Error>) -> Swift.Void)?)
}
public class EmbraceUpload : EmbraceUploadInternal.EmbraceLogUploader {
  public var options: EmbraceUploadInternal.EmbraceUpload.Options {
    get
  }
  public var logger: any EmbraceCommonInternal.InternalLogger {
    get
  }
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public init(options: EmbraceUploadInternal.EmbraceUpload.Options, logger: any EmbraceCommonInternal.InternalLogger, queue: Dispatch.DispatchQueue) throws
  public func retryCachedData()
  public func uploadSpans(id: Swift.String, data: Foundation.Data, completion: ((Swift.Result<(), any Swift.Error>) -> Swift.Void)?)
  public func uploadLog(id: Swift.String, data: Foundation.Data, completion: ((Swift.Result<(), any Swift.Error>) -> Swift.Void)?)
  @objc deinit
}
public enum EmbraceUploadErrorCode : Swift.Int {
  case invalidMetadata
  case invalidData
  case operationCancelled
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum EmbraceUploadError : Swift.Error, Swift.Equatable {
  case incorrectStatusCodeError(_: Swift.Int)
  case internalError(_: EmbraceUploadInternal.EmbraceUploadErrorCode)
  public static func == (a: EmbraceUploadInternal.EmbraceUploadError, b: EmbraceUploadInternal.EmbraceUploadError) -> Swift.Bool
}
extension EmbraceUploadInternal.EmbraceUploadError : Foundation.LocalizedError, Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
}
extension EmbraceUploadInternal.EmbraceUpload {
  public class CacheOptions {
    public var cacheBaseUrl: Foundation.URL
    public var cacheFileName: Swift.String
    public var cacheFilePath: Swift.String {
      get
    }
    public var cacheLimit: Swift.UInt
    public var cacheDaysLimit: Swift.UInt
    public var cacheSizeLimit: Swift.UInt
    public init?(cacheBaseUrl: Foundation.URL, cacheFileName: Swift.String = "db.sqlite", cacheLimit: Swift.UInt = 0, cacheDaysLimit: Swift.UInt = 0, cacheSizeLimit: Swift.UInt = 0)
    @objc deinit
  }
}
extension EmbraceUploadInternal.EmbraceUpload {
  public class EndpointOptions {
    final public let spansURL: Foundation.URL
    final public let logsURL: Foundation.URL
    public init(spansURL: Foundation.URL, logsURL: Foundation.URL)
    @objc deinit
  }
}
extension EmbraceUploadInternal.EmbraceUpload {
  public class MetadataOptions {
    public var apiKey: Swift.String
    public var userAgent: Swift.String
    public var deviceId: Swift.String
    public init(apiKey: Swift.String, userAgent: Swift.String, deviceId: Swift.String)
    @objc deinit
  }
}
extension EmbraceUploadInternal.EmbraceUpload {
  public class Options {
    final public let endpoints: EmbraceUploadInternal.EmbraceUpload.EndpointOptions
    final public let cache: EmbraceUploadInternal.EmbraceUpload.CacheOptions
    final public let metadata: EmbraceUploadInternal.EmbraceUpload.MetadataOptions
    final public let redundancy: EmbraceUploadInternal.EmbraceUpload.RedundancyOptions
    final public let urlSessionConfiguration: Foundation.URLSessionConfiguration
    public init(endpoints: EmbraceUploadInternal.EmbraceUpload.EndpointOptions, cache: EmbraceUploadInternal.EmbraceUpload.CacheOptions, metadata: EmbraceUploadInternal.EmbraceUpload.MetadataOptions, redundancy: EmbraceUploadInternal.EmbraceUpload.RedundancyOptions = RedundancyOptions(), urlSessionConfiguration: Foundation.URLSessionConfiguration? = nil)
    @objc deinit
  }
}
extension EmbraceUploadInternal.EmbraceUpload {
  public class RedundancyOptions {
    public var automaticRetryCount: Swift.Int
    public var retryOnInternetConnected: Swift.Bool
    public init(automaticRetryCount: Swift.Int = 0, retryOnInternetConnected: Swift.Bool = true)
    @objc deinit
  }
}
extension EmbraceUploadInternal.EmbraceUploadErrorCode : Swift.Equatable {}
extension EmbraceUploadInternal.EmbraceUploadErrorCode : Swift.Hashable {}
extension EmbraceUploadInternal.EmbraceUploadErrorCode : Swift.RawRepresentable {}
